课后作业（编码）
通过该作业，您可以查看一些实际的代码，这些代码会发生死锁（或避免死锁）。
在简单的 vector_add() 函数中，不同版本的代码对应不同的避免死锁的方法。 
有关这些程序及其常用基础的详细信息，请参见 README。

问题：

<br/>
<br/>

1.首先，先了解程序的总体运行方式以及一些关键选项。 研究 vector-deadlock.c，main-common.c 和相关文件中的代码。
现在运行 `./vector-deadlock -n 2 -l 1 -v`，它指定运行两个线程（-n 2），每个线程执行一次 vector_add （-l 1），
并以详细模式（-v）执行 。 确保你能理解输出。 输出在程序运行时如何变化？

<br/>
<br/>

2.现在添加-d 标志，并将循环次数（-l）从 1 更改为更高的数字。会发生什么？ 代码（总是）会死锁吗？

<br/>
<br/>

3.更改线程数（-n），程序的运行结果会发生什么变化？ 是否有 -n 的值可确保不发生死锁？

<br/>
<br/>

4.现在查看 `vector-global-order.c` 中的代码。 首先，请确保您理解代码的执行过程； 
您理解为什么代码能避免死锁吗？ 另外，当源和目标 vectors 相同时，为什么在这个 vector_add（）中有特殊情况发生？

<br/>
<br/>

5.现在，运行带有以下参数的代码：`-t -n 2 -l 100000 -d`。 
代码需要多长时间才能运行完成？ 当您增加循环数或线程数时，总时间如何变化？

<br/>
<br/>

6.如果打开并行标志（-p），会发生什么？ 当每个线程修改不同的 vectors（-p 启用）而不是在相同的 vectors 上运行时，您期望性能变化多少？

<br/>
<br/>

7.现在我们研究 `vector-try-wait.c`。 首先确保您理解代码。 第一个对互斥锁 trylock（）的调用有必要吗？ 
现在运行代码。 顺序运行方法相比，它运行速度有多快？ retry 变量大小（记录 trylock 尝试次数）如何随着线程数的增加而变化？

<br/>
<br/>

8.现在让我们看一下`vector-avoid-hold-and-wait.c`。 这种方法的主要问题是什么？ 
在使用 -p 和不使用 -p 的情况下，其性能与其他版本相比如何？

<br/>
<br/>

9.最后，让我们看一下 `vector-nolock.c`。 这个版本根本不使用锁； 它提供与其他版本完全相同的语义吗？ 为什么或者为什么不？

<br/>
<br/>

10.当线程在相同的两个 vectors 上运行时（没有 -p 参数），以及每个线程在单独的 vectors 上工作时（-p），
与其他版本进行比较。无锁版本的性能如何？

