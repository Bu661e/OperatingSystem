课后作业（编码）：

在这个作业中，我们将学习几个有用的工具来检查基于 linux 的系统上的虚拟内存使用情况。
这将只是一个简短的暗示什么是可能的;你必须靠自己更深入地研究，才能真正成为一名专家(一如既往!)


问题：

<br/>
<br/>

1.您应该查看的第一个 Linux 工具是一个非常简单的叫做 free 的工具。输入 man free ，阅读整个手册;它很短，别担心

[free 中文手册](https://github.com/man-pages-zh/manpages-zh/blob/d3db01c0bbcae067a6af11edbe61613b373b26cc/src/man1/free.1)

<br/>
<br/>

2.现在运行 free ，使用一些有用的参数(例如：-m，以兆字节为单位显示内存总数)。你的系统有多少内存?有多少是空闲的?这些数字和你的直觉相符吗？

<pre>
free -m
free -h
</pre>

<br/>
<br/>

3.接下来，创建一个使用一定内存的小程序，称为 memory-user.c。这个程序应该接受一个命令行参数：它将使用的内存的兆字节数。在运行时，它应该分配一个数组，
并不断地遍历数组，访问每个元素. 程序应该无限期地这样做，或者使用命令行参数指定的运行时间。
            

<br/>
<br/>

4.在运行 memory-user 程序时，同时运行 free 工具(在不同的终端窗口中，但在同一台机器上)。
当你的程序在运行时，内存使用总量是如何变化的?那么当您终止 memory-user 程序时呢?这些数字符合你的预期吗?尝试制定不同的内存使用量来进行实验。
当你使用大量内存时会发生什么

```shell script
gcc memory-user -g 
./a.out 1 20
./a.out 10 20
./a.out 100 20
./a.out 4000 20
```


<br/>
<br/>

5.让我们尝试使用另一个工具，它叫做 pmap。花点时间，详细阅读 pmap 手册页。


<br/>
<br/>

6.要使用 pmap，您必须知道感兴趣的进程的进程 ID。因此，首先运行 ps -auxw 查看所有进程的列表;
然后，选择一个有趣的，比如浏览器进程。在这种情况下，您也可以使用 memory-user 程序(实际上，为了方便，您甚至可以让该程序调用 getpid() 并打印它的 PID)。

```shell script
pmap -x $(pid)
```

<br/>
<br/>

7.现在，使用各种标志（例如 -X）在一些进程上运行 pmap，以显示有关该进程的许多详细信息。 你看到了什么？ 
与我们简单的代码/堆栈/堆概念不同，有多少不同的实体构成了现代地址空间？

<pre>
❯ pmap -x 32742
32742:   ./a.out 100 100
地址               Kbytes     RSS   Dirty Mode  Mapping
0000558b593d4000       4       4       4 r---- a.out
0000558b593d5000       4       4       4 r-x-- a.out
0000558b593d6000       4       4       4 r---- a.out
0000558b593d7000       4       4       4 r---- a.out
0000558b593d8000       4       4       4 rw--- a.out
0000558b59fe3000     132       4       4 rw---   [ anon ]
00007f4738a20000  102404  102404  102404 rw---   [ anon ]
00007f473ee21000     148     144       0 r---- libc-2.31.so
00007f473ee46000    1504     984       0 r-x-- libc-2.31.so
00007f473efbe000     296     124       0 r---- libc-2.31.so
00007f473f008000       4       0       0 ----- libc-2.31.so
00007f473f009000      12      12      12 r---- libc-2.31.so
00007f473f00c000      12      12      12 rw--- libc-2.31.so
00007f473f00f000      24      24      24 rw---   [ anon ]
00007f473f032000       4       4       0 r---- ld-2.31.so
00007f473f033000     140     140       0 r-x-- ld-2.31.so
00007f473f056000      32      32       0 r---- ld-2.31.so
00007f473f05f000       4       4       4 r---- ld-2.31.so
00007f473f060000       4       4       4 rw--- ld-2.31.so
00007f473f061000       4       4       4 rw---   [ anon ]
00007ffc9760a000     136      20      20 rw---   [ stack ]
00007ffc9767a000      12       0       0 r----   [ anon ]
00007ffc9767d000       4       4       0 r-x--   [ anon ]
ffffffffff600000       4       0       0 --x--   [ anon ]
---------------- ------- ------- ------- 
total kB          104900  103940  102508
</pre>

其中：
- Address：地址空间映射开始地址
- Kbytes: 映射大小
- RSS：Resident Set Size，常驻内存大小
- Dirty：脏页(共享的和私有的)单位为千字节
- Mode： 权限（读、写、执行）  
- Mapping: 文件映射（file backed）,  [ anon ] 匿名映射, 或 [ stack ] 程序 stack 映射

[参考](https://serverfault.com/questions/274460/what-does-kbytes-rss-dirty-mean-for-pmap)     

<br/>
<br/>

8.最后，让我们在 memory-user 程序上运行 pmap，指定不同的内存使用。你看到了什么? pmap 的输出是否符合您的期望
