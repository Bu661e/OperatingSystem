<br/>
<br/>

1.使用以下参数生成随机地址：－s0-n 10,-s 1-n 10 和－s2-n 10.将策略从 FIFO 更改
为 LRU,并将其更改为 OPT.计算所述地址追踪中的每个访问是否命中或未命中。
<br/>
<br/>

2.对于大小为 5 的高速缓存，为以下每个策略生成最差情况的地址引用序列：FIFO、
LRU 和 MRU(最差情况下的引用序列导致尽可能多的未命中）。对于最差情况下的引用序
列，需要的缓存增大多少，才能大幅提高性能，并接近 OPT?
<br/>
<br/>

3.生成一个随机追踪序列（使用 Python 或 Perl).你预计不同的策略在这样的追踪序

列上的表现如何？
<br/>
<br/>

4.现在生成一些局部性追踪序列。如何能够产生这样的追踪序列？LRU 表现如何？RAND
比 LRU 好多少？CLOCK 表现如何？CLOCK 使用不同数量的时钟位，表现如何？
<br/>
<br/>

5.使用像 valgrind 这样的程序来测试真实应用程序并生成虚拟页面引用序列。例如，运行 valgrind-tool=lackey--trace-mem=yes ls 将为程序 1s 所做的每个指令和数据引用，输出近乎完
整的引用追踪。为了使上述仿真器有用，你必须首先将每个虚拟内存引用转换为虚拟页码参考（通过屏蔽偏移量并向右移位来完成）。为了满足大部分请求，你的应用程序追踪需要多大的缓存？随着缓存大小的增加绘制其工作集的图形。