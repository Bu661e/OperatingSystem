测量作业是小型练习。



你可以编写代码在真实机器上运行,从而测量操作系统或硬件性能的某些方面。这样的作业背后的想法是给你一点实际操作系统的实践经验。在这个作业中,你将测量系统调用和上下文切换的成本。测量系统调用的成本相对容易。例如,你可以重复调用一个简单的系统调用(例如,执行 0 字节读取)并记下所花的时间。将时间除以迭代次数,就可以估计系统调用的成本。你必须考虑的一件事是时钟的精确性和准确性。你可以使用的典型时钟是`gettimeofday`详细信息请阅读手册。你会看到, `gettimeofday`返回自 1970 年以来的微秒时间。然而,这并不意味着时钟精确到微秒。测量 `gettimeofday` 的连续调用,以了解时钟的精确度。这会告诉你为了获得一个好的测量结果,需要让空系统调用测试的迭代运行多少次。如果`gettimeofday`对你来说不够精确,可以考虑利用 x86 机器提供的 `rdtsc`指令测量上下文切换的成本有点棘手。 Imbench 基准测试的实现方法,是在单个 CPU 上运行两个进程并在它们之间设置两个 UNX 管道。管道只是 U 系统中的进程可以相互通信的许多方式之一。第一个进程向第一个管道写入数据,然后等待第二个数据的读取。由于看到第一个进程等待从第二个管道读取的内容,OS 将第一个进程置于阻塞状态,并切换到另一个进程,该进程从第一个管道读取数据,然后写入第二个管理第二个进程再次尝试从第一个管道读取时,它会阻塞,从而继续进行通信的往返循环。通过反复测量这种通信的成本, Imbench 可以很好地估计上下文切换的成本。你可以尝试使用管道或其他通信机制(例如 UNIX 套接字),重新创建类似的东西。在具有多个 CPU 的系统中,测量上下文切换成本有一点困难。在这样的系统上,你需要确保你的上下文切换进程处于同一个处理器上。幸运的是,大多数操作系统都会提供系统调用,让一个进程绑定到特定的处理器。例如,在 Linux 上, `sched_setaffinity`调用就是你要查找的内容。通过确保两个进程位于同一个处理器上,你就能确保在测量操作系统停止一个进程并在同一个 CPU 上恢复另一个进程的成本。