课后作业(编码)
在本节中，我们将编写一些简单的多线程程序，并使用一个叫`helgrind`的特定工具来查找程序中的问题。
阅读作业中的 README 文件，以获取有关如何构建程序和运行`helgrind`的详细信息。

问题:
<br/>
<br/>

1.首先构建`main-race.c`.查看代码，以便您可以在代码中看到（非常明显的）数据竞争。 
现在运行`helgrind`（通过输入`valgrind --tool = helgrind main-race`）来查看其追踪结果。 
它指向正确的代码行吗？ 它还能为您提供什么其他信息？

<br/>
<br/>

2.删除有问题的代码行之一会发生什么？ 现在，在一个共享变量的更新附近添加锁，然后在所有变量更新周围添加锁。 
在每种情况下，`Helgrind`报告什么？

<br/>
<br/>

3.现在让我们看一下`main-deadlock.c`. 查看代码。 代码中有一个死锁的问题（我们将在下一章中对此进行更深入的讨论）。 您知道它可能有什么问题吗？
  
<br/>
<br/>

4.现在运行`helgrind`检查这段代码。 `Helgrind`报告什么？
 
<br/>
<br/>

5.现在使用`main-deadlock-global.c`运行`helgrind`。 查看代码；
它有和`main-deadlock.c`有一样的问题吗？ `Helgrind`是否应该报告相同的错误？ 对于`helgrind`之类的工具,结果说明了什么？
  
<br/>
<br/>

6.接下来让我们看一下`main-signal.c`。 这段代码使用变量（done）来表示子进程已完成，并且父线程现在可以继续运行了。 
为什么这段代码效率低下？ （父最终会花时间做什么，特别是当子线程需要很长时间才能执行完成时？）

<br/>
<br/>

7.现在在这个程序上运行`helgrind`。它报告什么?代码正确吗?

<br/>
<br/>

8.现在看一下`main-signal.c`稍微修改的版本:`main-signal-cv.c`。
该版本使用条件变量来发送信号（并进行加锁）。 为什么此代码比以前的版本更好？ 是正确，还是性能，或两者兼而有之？
  
<br/>
<br/>

9.再一次在`main-signal-cv.c`上运行`helgrind`。它报告错误吗?

