作业（模拟）



<br/>
<br/>

在本作业中，我们将使用 multi.py 模拟多处理器 CPU 调度程序，并了解其一些详细信息。 阅读相关的自述文件，以获得有关模拟器及其选项的更多信息。



问题:

<br/>
<br/>

1.首先，让我们学习如何使用模拟器来研究如何构建有效的多处理器调度程序。 第一次模拟将仅运行一个作业，该作业的运行时间为 30，工作集大小为 200。在一个模拟 CPU 上运行此作业（此处称为作业 “a”），如下所示：`./multi.py -n 1 -L a:30:200`。 作业完成需要多长时间？ 打开 -c 标志以查看最终答案，打开 -t 标志以查看每个时钟的作业及其调度方式。

```bash
python2 multi.py -n 1 -L a:30:200
python2 multi.py -n 1 -L a:30:200 -c -t
# Finished time 30
```





<br/>
<br/>

2.现在增加缓存大小，以使作业的工作集（大小为 200）匹配缓存大小（默认情况下，缓存大小为 100）；例如，运行 ` ./multi.py -n 1 -L a:30:200 -M 300`。你能否预测该作业放入缓存后将运行多快？ （提示：记住预热速率(warm rate)的关键参数，该参数是由 -r 标志设置的），通过在添加了 -c 标志来检查答案。

```bash
python2 multi.py -n 1 -L a:30:200 -M 300
python2 multi.py -n 1 -L a:30:200 -M 300 -c -t
# Finished time 20
# 默认 warmup time 为 10 个时间单位，10个时间单位后，处理速度翻倍（warmup rate）
```





<br/>
<br/>

3.关于 multi.py 的一件很酷的事情是，您可以使用不同跟踪标志来查看关于正在运行的作业的更多详细信息。运行与上个问题相同的参数运行，但是这次启用了剩余时间跟踪（-T）。这个标志显示在每个时间单位安排在 CPU上的作业，又显示每个时钟运行后该作业还剩下多少运行时间。 您如何看待第二列的数据减小的情况？

```bash
python2 multi.py -n 1 -L a:30:200 -M 300 -T
python2 multi.py -n 1 -L a:30:200 -M 300 -c -t -T
# 前 10 个时间单位 最后一列每次减少 1
# 缓存进入 warm 模式后，处理速度翻倍，最后一列每次减少 2
```



<br/>
<br/>



4.现在添加 -C 追踪标志，以显示每个作业的每个 CPU 缓存的状态。 如果作业的缓存很为冷(code)模式,缓存会显示一个空格,如果该作业的缓存为热(warm)模式,则显示 “ w”。 在这个简单的示例中，什么时候缓存对作业“a”变热(warm)了？ 将预热时间(warmup time)参数（-w）更改为比默认值低或高的值会发生什么？

```bash
python2 multi.py -n 1 -L a:30:200 -M 300 -T -C
python2 multi.py -n 1 -L a:30:200 -M 300 -c -t -T -C
# 第十个时间单位缓存变热（warm）
python2 multi.py -n 1 -L a:30:200 -M 300 -c -t -T -C
# warmup time 变短，缓存更快进入热模式，处理速度加快
```



<br/>
<br/>

5.您现在应该对模拟器在单个 CPU 上运行的单个作业的工作方式有一个很好的了解。但是，这不是一个有关多处理器CPU调度的章节吗？ 哦使得！ 因此，让我们开始处理多个作业。具体来说，让我们在两 CPU 系统上运行以下三个作业（即输入 `./multi.py -n 2 -L a:100:100,b:100:50,c:100:50`）您可以预测使用单队列集中调度程序，将需要多长时间？ 使用 -c 查看您是否正确，然后使用 -t 深入了解详细信息，然后逐步查看 -C，然后使用 -C查看缓存变热是否是作业能高效。 你注意到了什么？

```bash
python2 multi.py -n 2 -L a:100:100,b:100:50,c:100:50
python2 multi.py -n 2 -L a:100:100,b:100:50,c:100:50 -c
python2 multi.py -n 2 -L a:100:100,b:100:50,c:100:50 -c -t -C -T
# Finished time 150
# 添加 -M 50 参数，发现时间也是 150，也就是说没有变得高效
# 可以看到，abc三个进程并没有在固定的 CPU 上运行，且缓存被清除
```





<br/>
<br/>

6.现在，我们将使用一些参数来研究缓存亲和度。添加 -A 标志。这个标志可用于限制调度,指定作业可以在哪些 CPU 上运行。让我们使用这个标志,使作业 “ b” 和 “ c” 只能在 CPU 1 上运行，同时将  “a” 限制在 CPU 0上。通过输入此`./multi.py -n 2 -L a:100:100,b:100:50,c:100:50 -A a:0,b:1,c:1`可以实现此魔术。不要忘记打开各种跟踪选项以查看实际情况！ 您可以预测这个版本的运行速度吗？ 为什么这个版本更好？ 将两个处理器上的“ a”，“b” 和 “c” 作业的其他组合运行得更快还是更慢？

```bash
python2 ./multi.py -n 2 -L a:100:100,b:100:50,c:100:50 -A a:0,b:1,c:1
python2 ./multi.py -n 2 -L a:100:100,b:100:50,c:100:50 -A a:0,b:1,c:1 -c -C -t -T
# Finished time 110
# 这是最快的组合，a 作业独占cpu，应为它的工作所需缓存为 100，刚好占满空间，如果 a 与其他作业组合，则会导致两者都无法利用缓存
```





<br/>
<br/>

7.处理器缓存的一个有趣方面是，与使用单个 CPU 上运行的作业相比，使用多个 CPU（及其缓存）时，作业的加速速度好于预期。 具体来说，当作业在 N 个 CPU 上运行时，有时可以将速度提高 N 倍以上，这种情况称为超线性加速(super-linear speedup)。 要对此进行试验，请使用此处的这个参数:（`-L a:100:100,b:100:100,c:100:100`）和小的缓存（-M 50）创建三个作业。 在具有 1 个，2 个和 3 个CPU（-n 1、-n 2、-n 3）的系统上运行。 现在，执行相同的操作，但是每个 CPU 的高速缓存大小为 100。随着 CPU 数量的增加，性能如何变化？ 使用 -c 确认你的猜测，并使用其他跟踪标志进一步深入了解。

```bash
python2 multi.py -n 1 -L a:100:100,b:100:100,c:100:100 -M 50 -c -C -t -T 
# Finished time 300
python2 multi.py -n 2 -L a:100:100,b:100:100,c:100:100 -M 50 -c -C -t -T 
# Finished time 150
python2 multi.py -n 3 -L a:100:100,b:100:100,c:100:100 -M 50 -c -C -t -T 
# Finished time 100
python2 multi.py -n 4 -L a:100:100,b:100:100,c:100:100 -M 50 -c -C -t -T 
# Finished time 100

python2 multi.py -n 1 -L a:100:100,b:100:100,c:100:100 -M 100 -c -C -t -T 
# Finished time 300
python2 multi.py -n 2 -L a:100:100,b:100:100,c:100:100 -M 100 -c -C -t -T 
# Finished time 150
python2 multi.py -n 3 -L a:100:100,b:100:100,c:100:100 -M 100 -c -C -t -T 
# Finished time 55
python2 multi.py -n 4 -L a:100:100,b:100:100,c:100:100 -M 100 -c -C -t -T 
# Finished time 55
```

上面四个是没有缓存的，下面四个有缓存，不过恰好只能缓存一个作业，因此，当只有两个 CPU 时，缓存并没有起作用，但 CPU 数量增加到 3 时，每个作业独占 CPU，缓存加速了作业处理。



<br/>
<br/>



8.模拟器值得研究的另一个方面是每个 CPU 的调度选项 -p 。再次使用两个 CPU 和这三个作业（`-L a:100:100,b:100:50,c:100:50`）运行。 这个选项的作用是什么？ 当您将“查看间隔”（-P）更改为较低或较高的值时，性能如何变化？ 随着 CPU 数量的增加，这种基于 CPU 的方法如何工作？

```bash
# -p 参数可以让每个 CPU 拥有一个调度队列 -P 参数设置检查队列的间隔，用于 CPU 负载均衡
python2 multi.py -L a:100:100,b:100:50,c:100:50 -c -p -P 0
# Finished time 200
python2 multi.py -L a:100:100,b:100:50,c:100:50 -c -p -P 10
# Finished time 100
python2 multi.py -L a:100:100,b:100:50,c:100:50 -c -p -P 40
# Finished time 115
python2 multi.py -L a:100:100,b:100:50,c:100:50 -c -p -P 100
# Finished time 130
```



<br/>
<br/>

9.最后，随意生成随机工作负载，看看是否可以预测它们在不同数量的处理器，缓存大小和调度选项上的性能。 如果这样做，您很快就会成为多处理器调度大师，这将是一件非常棒的事情。 祝好运！