这个有趣(fun)的小作业测试你是否理解多级页表的工作原理。
是的，对于前一句中 fun 这个词的使用存在一些争议。
运行程序:`paging-multilevel-translate.py`

```shell script
paging-multilevel-translate.py
```

一些基本的假设:

- 页面大小是一个小得不真实的 32 字节
- 该进程的虚拟地址空间（假设只有一个）为 1024 页或 32 KB
- 物理内存由 128 页组成

因此，虚拟地址需要 15 位（偏量为 5 位，VPN 为 10 位）。 
物理地址需要 12 位（偏移为 5 为，PFN 为 7）。

系统使用一个多级页表。 
因此，虚拟地址的高五位用于索引页面目录。 
页目录项（PDE）（如果有效）指向页表的页面。 
每个页表页包含 32 个页表项（PTE）。 
每个 PTE（如果有效）均保存问题虚拟页面的所需转换（物理帧号或 PFN）。


PTE 的格式为：
<pre>
  VALID | PFN6 ... PFN0
</pre>
因此是 8 位或 1 字节。


PDE 的格式本质上是相同的：
<pre>
  VALID | PT6 ... PT0
</pre>

首先你有两条信息可以获取

首先，为您提供页面目录基址寄存器（PDBR）的值，该值告诉您页面目录位于哪个页面上。

其次，您将获得每个内存页面的完整转储。 页面转储如下所示：
(Second, you are given a complete dump of each page of memory. A page dump
looks like this:) 

<pre>
    page 0: 08 00 01 15 11 1d 1d 1c 01 17 15 14 16 1b 13 0b ...
    page 1: 19 05 1e 13 02 16 1e 0c 15 09 06 16 00 19 10 03 ...
    page 2: 1d 07 11 1b 12 05 07 1e 09 1a 18 17 16 18 1a 01 ...
    ...
</pre>

它显示了在第 0、1、2 等页上找到的 32 个字节。 
页面 0 上的第一个字节（第 0 个字节）的值为 0x08，第二个为 0x00，第三个为 0x01，依此类推。

然后你会得到一个虚拟地址的列表来进行转换

使用 PDBR 查找该虚拟页面的相关页表项。 然后找到它是否有效。 
然后进行转换形成最终的物理地址。 使用此地址，您可以找到内存引用正在寻找的值。

当然，虚拟地址可能无效，因此会产生错误

一些有用的参数
<pre>
  -s SEED, --seed=SEED       随机种子
  -n NUM, --addresses=NUM    生成虚拟地址数量
  -c, --solve                计算答案
</pre>

一如既往地更改种子以获得不同的问题。

更改生成的虚拟地址的数量，以便对给定的内存转储进行更多的转换。

使用 -c (或 --solve) 计算解决方案.

